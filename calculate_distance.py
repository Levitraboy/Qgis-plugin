# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CalculateDistance
                                 A QGIS plugin
 This plugin calculates the distances between end points of the lines or the distance between the closest and the furthest points in a point set.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-12-24
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Hacettepe University
        email                : Hacettepe University
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox
from PyQt5.QtGui import *
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .calculate_distance_dialog import CalculateDistanceDialog
from qgis.core import QgsProject, QgsDistanceArea , Qgis, QgsFields, QgsField, QgsVectorLayer, QgsFeature, QgsCoordinateReferenceSystem, QgsVectorFileWriter, QgsGeometry, QgsGeometry, QgsPoint
from qgis.utils import iface
import os.path
from osgeo import ogr
import math
from itertools import product
from pathlib import Path
class CalculateDistance:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'CalculateDistance_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Calculate Distance')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('CalculateDistance', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/calculate_distance/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Find Distance'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Calculate Distance'),
                action)
            self.iface.removeToolBarIcon(action)

    def getLayers(self):
        self.vector_layers = [layer.name() for layer in QgsProject.instance().mapLayers().values() if (layer.type() == 0)]# and layer.wkbType() in (1,2,4,5))]
        self.dlg.cb_layers.clear()

        self.dlg.cb_layers.addItems(self.vector_layers)
        return self.vector_layers

    def readPath(self):
        self.layer_path = dir(QgsProject.instance().mapLayersByName(self.selectedLayerName)[0])
        return self.layer_path
    def fillFields(self):
        self.dlg.berk.clear()
        self.dlg.cb_layers_2.clear()
        self.dlg.cb_layers_3.clear()
        cb_layers_color_list = ["Red","Blue","Green"]
        cb_layers_thickness_list = ["Thin", "Thick", "Very thick"]

        try:
            self.selectedLayer = QgsProject.instance().mapLayersByName(self.dlg.cb_layers.currentText())[0]
        except:
            return

        if self.selectedLayer.wkbType() in (3,6):
            self.dlg.lbl_warning.setHidden(False)
            self.dlg.cb_layers_2.setEnabled(False)
            self.dlg.cb_layers_3.setEnabled(False)
            self.dlg.chc_use_id.setEnabled(False)
            self.dlg.toolButton.setEnabled(False)
            self.dlg.ln_outpath.setEnabled(False)
            self.dlg.berk.setEnabled(False)
            self.dlg.button_box.setEnabled(True)
            self.dlg.horizontalSlider.setEnabled(False)

        elif self.selectedLayer.wkbType() in (2,5):
            self.dlg.lbl_warning.setHidden(True)
            self.dlg.cb_layers_2.setEnabled(False)
            self.dlg.cb_layers_3.setEnabled(False)
            self.dlg.chc_use_id.setEnabled(False)
            self.dlg.toolButton.setEnabled(False)
            self.dlg.ln_outpath.setEnabled(False)
            self.dlg.berk.setEnabled(False)
            self.dlg.button_box.setEnabled(True)
            self.dlg.horizontalSlider.setEnabled(False)


        else:
            self.dlg.lbl_warning.setHidden(True)
            self.dlg.cb_layers_2.setEnabled(True)
            self.dlg.cb_layers_3.setEnabled(True)
            self.dlg.chc_use_id.setEnabled(True)
            self.dlg.toolButton.setEnabled(True)
            self.dlg.ln_outpath.setEnabled(True)
            self.dlg.berk.setEnabled(True)
            self.dlg.button_box.setEnabled(True)
            self.dlg.horizontalSlider.setEnabled(True)

            self.fields = [field.name() for field in self.selectedLayer.fields()]
            if self.fields:
                self.dlg.berk.addItems(self.fields)
            else:
                self.dlg.berk.addItem("No Available Field!")

            #for i in cb_layers_color_list:
            self.dlg.cb_layers_2.addItems(cb_layers_color_list)
            self.dlg.cb_layers_3.addItems(cb_layers_thickness_list)

    def useId(self):
        clicked = self.dlg.chc_use_id.isChecked()
        if clicked:
            self.dlg.berk.setEnabled(False)
            self.dlg.berk.clear()
        else:
            self.dlg.berk.setEnabled(True)
            self.fillFields()

    def select_output(self):
        self.dlg.ln_outpath.setText("")
        self.shpPath, self._filter = QFileDialog.getSaveFileName(self.dlg, "Select output shp file", "", '*.shp')
        self.dlg.ln_outpath.setText(self.shpPath)

    def GetDistance(self, x1, y1, x2, y2):
        return math.sqrt((y2 - y1)**2 + (x2 - x1)**2)

    def getId(self,laer,min_x1_coor,min_y1_coor,min_x2_coor,min_y2_coor,max_x1_coor,max_y1_coor, max_x2_coor,max_y2_coor):
        array = [0,0,0,0]
        self.laer = laer
        features = self.laer.getFeatures()
        for feat in features:
            geom = feat.geometry()
            x = geom.asPoint()[0]
            y = geom.asPoint()[1]

            if(x == min_x1_coor and y == min_y1_coor):
                array[0] = int(feat['id'])
            elif(x == min_x2_coor and y == min_y2_coor):
                array[1] = int(feat['id'])
            elif(x == max_x1_coor and y == max_y1_coor):
                array[2] = int(feat['id'])
            elif(x == max_x2_coor and y == max_y2_coor):
                array[3] = int(feat['id'])

        return array
    def run(self):
        """Run method that performs all the real work"""
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            # self.first_start = False
            self.dlg = CalculateDistanceDialog()
            self.getLayers()
            #self.path = self.readPath()
            self.fillFields()



            self.dlg.cb_layers.currentTextChanged.connect(self.fillFields)
            self.dlg.chc_use_id.toggled.connect(self.useId)

            self.dlg.toolButton.clicked.connect(self.select_output)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()

        # See if OK was pressed
        if result:
            self.selectedLayerName = self.dlg.cb_layers.currentText()
            self.selectedBerkName = self.dlg.berk.currentText()


            self.layer = QgsProject.instance().mapLayersByName(self.selectedLayerName)[0]
            self.direction = os.path.dirname(unicode(self.layer.dataProvider().dataSourceUri()));

            self.data = ogr.Open(self.direction)
            self.layer_deneme = self.data.GetLayer()
            self.geom_type_deneme = ogr.GeometryTypeToName(self.layer_deneme.GetGeomType())

            self.geom_type = self.layer.wkbType()

            if(self.geom_type == 3 or self.geom_type == 6):
                print("A (multi)POLYGON layer is selected")
            elif(self.geom_type == 5):
                print("A LINE layer is selected")
            elif(self.geom_type == 1):
                print("A POINT layer is selected")

            if (self.geom_type == 1) or (self.geom_type == 4):
                points = []
                for feat in self.layer_deneme:
                    geom = feat.geometry()
                    if geom.GetGeometryName() == 'MULTIPOINT':
                        for i in geom:
                            x, y = i.GetPoint_2D()
                            points.append([x, y])
                    elif geom.GetGeometryName() == 'POINT':
                        x, y = geom.GetPoint_2D()
                        points.append([x, y])

                prod_points = product(points, points)

                max_x1_coor, max_y1_coor = 0, 0
                max_x2_coor, max_y2_coor = 0, 0
                max_dist = 0

                min_x1_coor, min_y1_coor = points[0]
                min_x2_coor, min_y2_coor = points[1]
                min_dist = self.GetDistance(min_x1_coor, min_y1_coor, min_x2_coor, min_y2_coor)

                for p1, p2 in prod_points:
                    x1_coor, y1_coor = p1
                    x2_coor, y2_coor = p2

                    if (x1_coor != x2_coor) and (y1_coor != y2_coor):
                        dist = self.GetDistance(x1_coor, y1_coor, x2_coor, y2_coor)
                        if (dist > max_dist):
                            max_x1_coor, max_y1_coor = p1
                            max_x2_coor, max_y2_coor = p2
                            max_dist = dist

                        elif (dist < min_dist):
                            min_x1_coor, min_y1_coor = p1
                            min_x2_coor, min_y2_coor = p2
                            min_dist = dist

                furthest_line = ogr.Geometry(ogr.wkbLineString)
                furthest_line.AddPoint_2D(max_x1_coor, max_y1_coor)
                furthest_line.AddPoint_2D(max_x2_coor, max_y2_coor)

                nearest_line = ogr.Geometry(ogr.wkbLineString)
                nearest_line.AddPoint_2D(min_x1_coor, min_y1_coor)
                nearest_line.AddPoint_2D(min_x2_coor, min_y2_coor)

                start_end_id = self.getId(self.layer, min_x1_coor, min_y1_coor, min_x2_coor, min_y2_coor, max_x1_coor, max_y1_coor,
                       max_x2_coor, max_y2_coor)

                layer = QgsVectorLayer("LineString?crs=epsg:4326", "line", "memory")
                prov = layer.dataProvider()
                layer_2 = QgsVectorLayer("LineString?crs=epsg:4326", "line", "memory")
                prov_2 = layer_2.dataProvider()
                if self.selectedBerkName == "id":
                    prov.addAttributes([QgsField("Start ID", QVariant.String),
                                        QgsField("End ID", QVariant.String),
                                        QgsField("Length", QVariant.Int)])
                    layer.updateFields()
                    point_near = QgsPoint(min_x1_coor, min_y1_coor)
                    point_near_2 = QgsPoint(min_x2_coor, min_y2_coor)
                    featt = QgsFeature()
                    featt.setGeometry(QgsGeometry.fromPolyline([point_near, point_near_2]))
                    featt.setAttributes([start_end_id[0], start_end_id[1], min_dist])
                    prov.addFeatures([featt])
                    layer.updateExtents()


                    prov_2.addAttributes([QgsField("Start ID", QVariant.String),
                                        QgsField("End ID", QVariant.String),
                                        QgsField("Length", QVariant.Int)])
                    layer_2.updateFields()
                    point_furthest = QgsPoint(max_x1_coor, max_y1_coor)
                    point_furthest_2 = QgsPoint(max_x2_coor, max_y2_coor)
                    featt_2 = QgsFeature()
                    featt_2.setGeometry(QgsGeometry.fromPolyline([point_furthest, point_furthest_2]))
                    featt_2.setAttributes([start_end_id[2], start_end_id[3], max_dist])
                    prov_2.addFeatures([featt_2])
                    layer_2.updateExtents()

                else:
                    prov.addAttributes([QgsField("Length", QVariant.Int)])
                    layer.updateFields()
                    point_near = QgsPoint(min_x1_coor, min_y1_coor)
                    point_near_2 = QgsPoint(min_x2_coor, min_y2_coor)
                    featt = QgsFeature()
                    featt.setGeometry(QgsGeometry.fromPolyline([point_near,point_near_2]))
                    featt.setAttributes([min_dist])
                    prov.addFeatures([featt])
                    layer.updateExtents()

                    prov_2.addAttributes([QgsField("Length", QVariant.Int)])
                    layer_2.updateFields()
                    point_furthest = QgsPoint(max_x1_coor, max_y1_coor)
                    point_furthest_2 = QgsPoint(max_x2_coor, max_y2_coor)
                    featt_2 = QgsFeature()
                    featt_2.setGeometry(QgsGeometry.fromPolyline([point_furthest,point_furthest_2]))
                    featt_2.setAttributes([max_dist])
                    prov_2.addFeatures([featt_2])
                    layer_2.updateExtents()

                self.shpPath = self.dlg.ln_outpath.text()
                near = f'{os.path.splitext(self.shpPath)[0] + "_nearest" + os.path.splitext(self.shpPath)[1]}'
                furths = f'{os.path.splitext(self.shpPath)[0] + "_furthest" + os.path.splitext(self.shpPath)[1]}'
                QgsVectorFileWriter.writeAsVectorFormat(layer,near,"UTF-8",layer.crs(), "ESRI Shapefile")
                QgsVectorFileWriter.writeAsVectorFormat(layer_2,furths, "UTF-8", layer.crs(), "ESRI Shapefile")


                vlayer = QgsVectorLayer(near,Path(near).stem, "ogr")
                vlayer.renderer().symbol().setColor(QColor(self.dlg.cb_layers_2.currentText()))
                if self.dlg.cb_layers_3.currentText() == "Thin":
                    vlayer.renderer().symbol().setWidth(0.5)
                elif self.dlg.cb_layers_3.currentText() == "Thick":
                    vlayer.renderer().symbol().setWidth(1)
                if self.dlg.cb_layers_3.currentText() == "Very thick":
                    vlayer.renderer().symbol().setWidth(2)
                vlayer.renderer().symbol().setOpacity(self.dlg.horizontalSlider.value() / 100)
                vlayer.triggerRepaint()
                QgsProject.instance().addMapLayer(vlayer)

                vlayer_2 = QgsVectorLayer(furths,Path(furths).stem, "ogr")
                vlayer_2.renderer().symbol().setColor(QColor(self.dlg.cb_layers_2.currentText()))
                if self.dlg.cb_layers_3.currentText() == "Thin":
                    vlayer_2.renderer().symbol().setWidth(0.5)
                elif self.dlg.cb_layers_3.currentText() == "Thick":
                    vlayer_2.renderer().symbol().setWidth(1)
                if self.dlg.cb_layers_3.currentText() == "Very thick":
                    vlayer_2.renderer().symbol().setWidth(2)
                vlayer_2.renderer().symbol().setOpacity(self.dlg.horizontalSlider.value() / 100)
                vlayer_2.triggerRepaint()
                QgsProject.instance().addMapLayer(vlayer_2)

                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setText("Max distance: {} \nMin distance: {}".format(max_dist, min_dist))
                msgBox.setWindowTitle("Distances")
                msgBox.exec()

            elif (self.geom_type == 2) or (self.geom_type == 5):
                if not self.layer.isValid():
                    print("Layer failed to load!")

                else:
                    QgsProject.instance().addMapLayer(self.layer)

                    oznitelikler = self.layer.fields().names()

                    print(oznitelikler)

                    eklenecekOznitelikler = ["minMesafe", "gercekMes"]
                    self.layer.startEditing()
                    dp = self.layer.dataProvider()

                    for isim in eklenecekOznitelikler:
                        if not isim in oznitelikler:
                            dp.addAttributes([QgsField(isim, QVariant.Double)])

                    self.layer.updateFields()

                lines = [feat for feat in self.layer.getFeatures()]

                if len(lines) > 0:
                    sCrs = self.layer.sourceCrs()
                    print("crs: ", sCrs)
                    d = QgsDistanceArea()
                    d.setEllipsoid(sCrs.ellipsoidAcronym())

                    for cizgi in lines:
                        geom = cizgi.geometry()
                        gercekMesafe = d.measureLine(geom.asMultiPolyline()[0])

                        print(gercekMesafe)

                        baslangicNoktasi = geom.constGet()[0][0]
                        bitisNoktasi = geom.constGet()[0][-1]

                        print("baslangic noktasi: ", baslangicNoktasi)
                        print("bitis noktasi: ", bitisNoktasi)

                        minCizgi = QgsFeature()
                        minCizgi.setGeometry(QgsGeometry.fromPolyline([baslangicNoktasi, bitisNoktasi]))

                        minMesafe = d.measureLine(minCizgi.geometry().asPolyline())

                        print("minimum mesafe : ", minMesafe)

                        cizgi["minMesafe"] = minMesafe
                        cizgi["gercekMes"] = gercekMesafe
                        self.layer.updateFeature(cizgi)

                    self.layer.updateFields()
                    self.layer.commitChanges()

                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setText("Min distance: {} \nActual distance: {}".format(minMesafe, gercekMesafe))
                msgBox.setWindowTitle("Distances")
                msgBox.exec()


